// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sales.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
    code,
    name,
    contact_person,
    email,
    phone,
    address,
    tax_id,
    credit_limit,
    payment_terms,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, code, name, created_at
`

type CreateCustomerParams struct {
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	TaxID         sql.NullString `json:"tax_id"`
	CreditLimit   sql.NullString `json:"credit_limit"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
}

type CreateCustomerRow struct {
	ID        uuid.UUID    `json:"id"`
	Code      string       `json:"code"`
	Name      string       `json:"name"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (CreateCustomerRow, error) {
	row := q.queryRow(ctx, q.createCustomerStmt, createCustomer,
		arg.Code,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.TaxID,
		arg.CreditLimit,
		arg.PaymentTerms,
		arg.IsActive,
	)
	var i CreateCustomerRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createCustomerInvoice = `-- name: CreateCustomerInvoice :one
INSERT INTO customer_invoices (
    invoice_number,
    customer_id,
    so_id,
    invoice_date,
    due_date,
    total_amount,
    status,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, invoice_number, customer_id, invoice_date, due_date, total_amount, status, created_at
`

type CreateCustomerInvoiceParams struct {
	InvoiceNumber string         `json:"invoice_number"`
	CustomerID    uuid.UUID      `json:"customer_id"`
	SoID          uuid.NullUUID  `json:"so_id"`
	InvoiceDate   time.Time      `json:"invoice_date"`
	DueDate       time.Time      `json:"due_date"`
	TotalAmount   string         `json:"total_amount"`
	Status        sql.NullString `json:"status"`
	Notes         sql.NullString `json:"notes"`
	CreatedBy     uuid.NullUUID  `json:"created_by"`
}

type CreateCustomerInvoiceRow struct {
	ID            uuid.UUID      `json:"id"`
	InvoiceNumber string         `json:"invoice_number"`
	CustomerID    uuid.UUID      `json:"customer_id"`
	InvoiceDate   time.Time      `json:"invoice_date"`
	DueDate       time.Time      `json:"due_date"`
	TotalAmount   string         `json:"total_amount"`
	Status        sql.NullString `json:"status"`
	CreatedAt     sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateCustomerInvoice(ctx context.Context, arg CreateCustomerInvoiceParams) (CreateCustomerInvoiceRow, error) {
	row := q.queryRow(ctx, q.createCustomerInvoiceStmt, createCustomerInvoice,
		arg.InvoiceNumber,
		arg.CustomerID,
		arg.SoID,
		arg.InvoiceDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.Status,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreateCustomerInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.CustomerID,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createQuotation = `-- name: CreateQuotation :one
INSERT INTO quotations (
    quote_number,
    customer_id,
    quote_date,
    valid_until,
    status,
    total_amount,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, quote_number, customer_id, quote_date, status, created_at
`

type CreateQuotationParams struct {
	QuoteNumber string         `json:"quote_number"`
	CustomerID  uuid.UUID      `json:"customer_id"`
	QuoteDate   time.Time      `json:"quote_date"`
	ValidUntil  sql.NullTime   `json:"valid_until"`
	Status      sql.NullString `json:"status"`
	TotalAmount sql.NullString `json:"total_amount"`
	Notes       sql.NullString `json:"notes"`
	CreatedBy   uuid.NullUUID  `json:"created_by"`
}

type CreateQuotationRow struct {
	ID          uuid.UUID      `json:"id"`
	QuoteNumber string         `json:"quote_number"`
	CustomerID  uuid.UUID      `json:"customer_id"`
	QuoteDate   time.Time      `json:"quote_date"`
	Status      sql.NullString `json:"status"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateQuotation(ctx context.Context, arg CreateQuotationParams) (CreateQuotationRow, error) {
	row := q.queryRow(ctx, q.createQuotationStmt, createQuotation,
		arg.QuoteNumber,
		arg.CustomerID,
		arg.QuoteDate,
		arg.ValidUntil,
		arg.Status,
		arg.TotalAmount,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreateQuotationRow
	err := row.Scan(
		&i.ID,
		&i.QuoteNumber,
		&i.CustomerID,
		&i.QuoteDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createQuotationLine = `-- name: CreateQuotationLine :one
INSERT INTO quotation_lines (
    quote_id,
    product_id,
    quantity,
    unit_price,
    line_number,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, quote_id, product_id, quantity, unit_price, subtotal, line_number
`

type CreateQuotationLineParams struct {
	QuoteID    uuid.UUID      `json:"quote_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   string         `json:"quantity"`
	UnitPrice  string         `json:"unit_price"`
	LineNumber int32          `json:"line_number"`
	Notes      sql.NullString `json:"notes"`
}

type CreateQuotationLineRow struct {
	ID         uuid.UUID      `json:"id"`
	QuoteID    uuid.UUID      `json:"quote_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   string         `json:"quantity"`
	UnitPrice  string         `json:"unit_price"`
	Subtotal   sql.NullString `json:"subtotal"`
	LineNumber int32          `json:"line_number"`
}

func (q *Queries) CreateQuotationLine(ctx context.Context, arg CreateQuotationLineParams) (CreateQuotationLineRow, error) {
	row := q.queryRow(ctx, q.createQuotationLineStmt, createQuotationLine,
		arg.QuoteID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.LineNumber,
		arg.Notes,
	)
	var i CreateQuotationLineRow
	err := row.Scan(
		&i.ID,
		&i.QuoteID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.LineNumber,
	)
	return i, err
}

const createSalesOrder = `-- name: CreateSalesOrder :one
INSERT INTO sales_orders (
    so_number,
    customer_id,
    quote_id,
    order_date,
    delivery_date,
    status,
    total_amount,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, so_number, customer_id, order_date, status, created_at
`

type CreateSalesOrderParams struct {
	SoNumber     string         `json:"so_number"`
	CustomerID   uuid.UUID      `json:"customer_id"`
	QuoteID      uuid.NullUUID  `json:"quote_id"`
	OrderDate    time.Time      `json:"order_date"`
	DeliveryDate sql.NullTime   `json:"delivery_date"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	Notes        sql.NullString `json:"notes"`
	CreatedBy    uuid.NullUUID  `json:"created_by"`
}

type CreateSalesOrderRow struct {
	ID         uuid.UUID      `json:"id"`
	SoNumber   string         `json:"so_number"`
	CustomerID uuid.UUID      `json:"customer_id"`
	OrderDate  time.Time      `json:"order_date"`
	Status     sql.NullString `json:"status"`
	CreatedAt  sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateSalesOrder(ctx context.Context, arg CreateSalesOrderParams) (CreateSalesOrderRow, error) {
	row := q.queryRow(ctx, q.createSalesOrderStmt, createSalesOrder,
		arg.SoNumber,
		arg.CustomerID,
		arg.QuoteID,
		arg.OrderDate,
		arg.DeliveryDate,
		arg.Status,
		arg.TotalAmount,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreateSalesOrderRow
	err := row.Scan(
		&i.ID,
		&i.SoNumber,
		&i.CustomerID,
		&i.OrderDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createSalesOrderLine = `-- name: CreateSalesOrderLine :one
INSERT INTO sales_order_lines (
    so_id,
    product_id,
    quantity,
    unit_price,
    line_number,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, so_id, product_id, quantity, unit_price, subtotal, line_number
`

type CreateSalesOrderLineParams struct {
	SoID       uuid.UUID      `json:"so_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   string         `json:"quantity"`
	UnitPrice  string         `json:"unit_price"`
	LineNumber int32          `json:"line_number"`
	Notes      sql.NullString `json:"notes"`
}

type CreateSalesOrderLineRow struct {
	ID         uuid.UUID      `json:"id"`
	SoID       uuid.UUID      `json:"so_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   string         `json:"quantity"`
	UnitPrice  string         `json:"unit_price"`
	Subtotal   sql.NullString `json:"subtotal"`
	LineNumber int32          `json:"line_number"`
}

func (q *Queries) CreateSalesOrderLine(ctx context.Context, arg CreateSalesOrderLineParams) (CreateSalesOrderLineRow, error) {
	row := q.queryRow(ctx, q.createSalesOrderLineStmt, createSalesOrderLine,
		arg.SoID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.LineNumber,
		arg.Notes,
	)
	var i CreateSalesOrderLineRow
	err := row.Scan(
		&i.ID,
		&i.SoID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.LineNumber,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT 
    id,
    code,
    name,
    contact_person,
    email,
    phone,
    address,
    tax_id,
    credit_limit,
    payment_terms,
    is_active,
    created_at,
    updated_at
FROM customers
WHERE id = $1 
    AND deleted_at IS NULL
LIMIT 1
`

type GetCustomerByIDRow struct {
	ID            uuid.UUID      `json:"id"`
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	TaxID         sql.NullString `json:"tax_id"`
	CreditLimit   sql.NullString `json:"credit_limit"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetCustomerByID(ctx context.Context, id uuid.UUID) (GetCustomerByIDRow, error) {
	row := q.queryRow(ctx, q.getCustomerByIDStmt, getCustomerByID, id)
	var i GetCustomerByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.TaxID,
		&i.CreditLimit,
		&i.PaymentTerms,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerInvoiceByID = `-- name: GetCustomerInvoiceByID :one
SELECT 
    ci.id,
    ci.invoice_number,
    ci.customer_id,
    c.name as customer_name,
    ci.so_id,
    ci.invoice_date,
    ci.due_date,
    ci.total_amount,
    ci.paid_amount,
    ci.status,
    ci.notes,
    ci.created_at
FROM customer_invoices ci
INNER JOIN customers c ON ci.customer_id = c.id
WHERE ci.id = $1
LIMIT 1
`

type GetCustomerInvoiceByIDRow struct {
	ID            uuid.UUID      `json:"id"`
	InvoiceNumber string         `json:"invoice_number"`
	CustomerID    uuid.UUID      `json:"customer_id"`
	CustomerName  string         `json:"customer_name"`
	SoID          uuid.NullUUID  `json:"so_id"`
	InvoiceDate   time.Time      `json:"invoice_date"`
	DueDate       time.Time      `json:"due_date"`
	TotalAmount   string         `json:"total_amount"`
	PaidAmount    sql.NullString `json:"paid_amount"`
	Status        sql.NullString `json:"status"`
	Notes         sql.NullString `json:"notes"`
	CreatedAt     sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetCustomerInvoiceByID(ctx context.Context, id uuid.UUID) (GetCustomerInvoiceByIDRow, error) {
	row := q.queryRow(ctx, q.getCustomerInvoiceByIDStmt, getCustomerInvoiceByID, id)
	var i GetCustomerInvoiceByIDRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.CustomerID,
		&i.CustomerName,
		&i.SoID,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.PaidAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getQuotationByID = `-- name: GetQuotationByID :one
SELECT 
    q.id,
    q.quote_number,
    q.customer_id,
    c.name as customer_name,
    q.quote_date,
    q.valid_until,
    q.status,
    q.total_amount,
    q.notes,
    q.created_at,
    q.updated_at
FROM quotations q
INNER JOIN customers c ON q.customer_id = c.id
WHERE q.id = $1
LIMIT 1
`

type GetQuotationByIDRow struct {
	ID           uuid.UUID      `json:"id"`
	QuoteNumber  string         `json:"quote_number"`
	CustomerID   uuid.UUID      `json:"customer_id"`
	CustomerName string         `json:"customer_name"`
	QuoteDate    time.Time      `json:"quote_date"`
	ValidUntil   sql.NullTime   `json:"valid_until"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	Notes        sql.NullString `json:"notes"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetQuotationByID(ctx context.Context, id uuid.UUID) (GetQuotationByIDRow, error) {
	row := q.queryRow(ctx, q.getQuotationByIDStmt, getQuotationByID, id)
	var i GetQuotationByIDRow
	err := row.Scan(
		&i.ID,
		&i.QuoteNumber,
		&i.CustomerID,
		&i.CustomerName,
		&i.QuoteDate,
		&i.ValidUntil,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuotationLines = `-- name: GetQuotationLines :many
SELECT 
    ql.id,
    ql.quote_id,
    ql.product_id,
    p.code as product_code,
    p.name as product_name,
    ql.quantity,
    ql.unit_price,
    ql.subtotal,
    ql.line_number,
    ql.notes
FROM quotation_lines ql
INNER JOIN products p ON ql.product_id = p.id
WHERE ql.quote_id = $1
ORDER BY ql.line_number
`

type GetQuotationLinesRow struct {
	ID          uuid.UUID      `json:"id"`
	QuoteID     uuid.UUID      `json:"quote_id"`
	ProductID   uuid.UUID      `json:"product_id"`
	ProductCode string         `json:"product_code"`
	ProductName string         `json:"product_name"`
	Quantity    string         `json:"quantity"`
	UnitPrice   string         `json:"unit_price"`
	Subtotal    sql.NullString `json:"subtotal"`
	LineNumber  int32          `json:"line_number"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) GetQuotationLines(ctx context.Context, quoteID uuid.UUID) ([]GetQuotationLinesRow, error) {
	rows, err := q.query(ctx, q.getQuotationLinesStmt, getQuotationLines, quoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuotationLinesRow
	for rows.Next() {
		var i GetQuotationLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.QuoteID,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.LineNumber,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesOrderByID = `-- name: GetSalesOrderByID :one
SELECT 
    so.id,
    so.so_number,
    so.customer_id,
    c.name as customer_name,
    so.quote_id,
    so.order_date,
    so.delivery_date,
    so.status,
    so.total_amount,
    so.notes,
    so.created_at,
    so.updated_at
FROM sales_orders so
INNER JOIN customers c ON so.customer_id = c.id
WHERE so.id = $1
LIMIT 1
`

type GetSalesOrderByIDRow struct {
	ID           uuid.UUID      `json:"id"`
	SoNumber     string         `json:"so_number"`
	CustomerID   uuid.UUID      `json:"customer_id"`
	CustomerName string         `json:"customer_name"`
	QuoteID      uuid.NullUUID  `json:"quote_id"`
	OrderDate    time.Time      `json:"order_date"`
	DeliveryDate sql.NullTime   `json:"delivery_date"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	Notes        sql.NullString `json:"notes"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetSalesOrderByID(ctx context.Context, id uuid.UUID) (GetSalesOrderByIDRow, error) {
	row := q.queryRow(ctx, q.getSalesOrderByIDStmt, getSalesOrderByID, id)
	var i GetSalesOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.SoNumber,
		&i.CustomerID,
		&i.CustomerName,
		&i.QuoteID,
		&i.OrderDate,
		&i.DeliveryDate,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesOrderLines = `-- name: GetSalesOrderLines :many
SELECT 
    sol.id,
    sol.so_id,
    sol.product_id,
    p.code as product_code,
    p.name as product_name,
    sol.quantity,
    sol.unit_price,
    sol.subtotal,
    sol.delivered_qty,
    sol.line_number,
    sol.notes
FROM sales_order_lines sol
INNER JOIN products p ON sol.product_id = p.id
WHERE sol.so_id = $1
ORDER BY sol.line_number
`

type GetSalesOrderLinesRow struct {
	ID           uuid.UUID      `json:"id"`
	SoID         uuid.UUID      `json:"so_id"`
	ProductID    uuid.UUID      `json:"product_id"`
	ProductCode  string         `json:"product_code"`
	ProductName  string         `json:"product_name"`
	Quantity     string         `json:"quantity"`
	UnitPrice    string         `json:"unit_price"`
	Subtotal     sql.NullString `json:"subtotal"`
	DeliveredQty sql.NullString `json:"delivered_qty"`
	LineNumber   int32          `json:"line_number"`
	Notes        sql.NullString `json:"notes"`
}

func (q *Queries) GetSalesOrderLines(ctx context.Context, soID uuid.UUID) ([]GetSalesOrderLinesRow, error) {
	rows, err := q.query(ctx, q.getSalesOrderLinesStmt, getSalesOrderLines, soID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesOrderLinesRow
	for rows.Next() {
		var i GetSalesOrderLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.SoID,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.DeliveredQty,
			&i.LineNumber,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCustomers = `-- name: ListActiveCustomers :many
SELECT 
    id,
    code,
    name,
    contact_person,
    email,
    phone,
    credit_limit,
    payment_terms,
    is_active
FROM customers
WHERE deleted_at IS NULL
    AND is_active = true
ORDER BY name
`

type ListActiveCustomersRow struct {
	ID            uuid.UUID      `json:"id"`
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	CreditLimit   sql.NullString `json:"credit_limit"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) ListActiveCustomers(ctx context.Context) ([]ListActiveCustomersRow, error) {
	rows, err := q.query(ctx, q.listActiveCustomersStmt, listActiveCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveCustomersRow
	for rows.Next() {
		var i ListActiveCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.CreditLimit,
			&i.PaymentTerms,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomerInvoices = `-- name: ListCustomerInvoices :many
SELECT 
    ci.id,
    ci.invoice_number,
    ci.customer_id,
    c.name as customer_name,
    ci.invoice_date,
    ci.due_date,
    ci.total_amount,
    ci.paid_amount,
    (ci.total_amount - ci.paid_amount) as outstanding,
    ci.status,
    ci.created_at
FROM customer_invoices ci
INNER JOIN customers c ON ci.customer_id = c.id
WHERE ($1::uuid IS NULL OR ci.customer_id = $1)
    AND ($2::varchar IS NULL OR ci.status = $2)
ORDER BY ci.due_date DESC, ci.invoice_number DESC
LIMIT $3 OFFSET $4
`

type ListCustomerInvoicesParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListCustomerInvoicesRow struct {
	ID            uuid.UUID      `json:"id"`
	InvoiceNumber string         `json:"invoice_number"`
	CustomerID    uuid.UUID      `json:"customer_id"`
	CustomerName  string         `json:"customer_name"`
	InvoiceDate   time.Time      `json:"invoice_date"`
	DueDate       time.Time      `json:"due_date"`
	TotalAmount   string         `json:"total_amount"`
	PaidAmount    sql.NullString `json:"paid_amount"`
	Outstanding   int32          `json:"outstanding"`
	Status        sql.NullString `json:"status"`
	CreatedAt     sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListCustomerInvoices(ctx context.Context, arg ListCustomerInvoicesParams) ([]ListCustomerInvoicesRow, error) {
	rows, err := q.query(ctx, q.listCustomerInvoicesStmt, listCustomerInvoices,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomerInvoicesRow
	for rows.Next() {
		var i ListCustomerInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.CustomerID,
			&i.CustomerName,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.Outstanding,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotations = `-- name: ListQuotations :many
SELECT 
    q.id,
    q.quote_number,
    q.customer_id,
    c.name as customer_name,
    q.quote_date,
    q.valid_until,
    q.status,
    q.total_amount,
    q.created_at
FROM quotations q
INNER JOIN customers c ON q.customer_id = c.id
WHERE ($1::uuid IS NULL OR q.customer_id = $1)
    AND ($2::varchar IS NULL OR q.status = $2)
    AND ($3::date IS NULL OR q.quote_date >= $3)
    AND ($4::date IS NULL OR q.quote_date <= $4)
ORDER BY q.quote_date DESC, q.quote_number DESC
LIMIT $5 OFFSET $6
`

type ListQuotationsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListQuotationsRow struct {
	ID           uuid.UUID      `json:"id"`
	QuoteNumber  string         `json:"quote_number"`
	CustomerID   uuid.UUID      `json:"customer_id"`
	CustomerName string         `json:"customer_name"`
	QuoteDate    time.Time      `json:"quote_date"`
	ValidUntil   sql.NullTime   `json:"valid_until"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListQuotations(ctx context.Context, arg ListQuotationsParams) ([]ListQuotationsRow, error) {
	rows, err := q.query(ctx, q.listQuotationsStmt, listQuotations,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListQuotationsRow
	for rows.Next() {
		var i ListQuotationsRow
		if err := rows.Scan(
			&i.ID,
			&i.QuoteNumber,
			&i.CustomerID,
			&i.CustomerName,
			&i.QuoteDate,
			&i.ValidUntil,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalesOrders = `-- name: ListSalesOrders :many
SELECT 
    so.id,
    so.so_number,
    so.customer_id,
    c.name as customer_name,
    so.order_date,
    so.delivery_date,
    so.status,
    so.total_amount,
    so.created_at
FROM sales_orders so
INNER JOIN customers c ON so.customer_id = c.id
WHERE ($1::uuid IS NULL OR so.customer_id = $1)
    AND ($2::varchar IS NULL OR so.status = $2)
    AND ($3::date IS NULL OR so.order_date >= $3)
    AND ($4::date IS NULL OR so.order_date <= $4)
ORDER BY so.order_date DESC, so.so_number DESC
LIMIT $5 OFFSET $6
`

type ListSalesOrdersParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListSalesOrdersRow struct {
	ID           uuid.UUID      `json:"id"`
	SoNumber     string         `json:"so_number"`
	CustomerID   uuid.UUID      `json:"customer_id"`
	CustomerName string         `json:"customer_name"`
	OrderDate    time.Time      `json:"order_date"`
	DeliveryDate sql.NullTime   `json:"delivery_date"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListSalesOrders(ctx context.Context, arg ListSalesOrdersParams) ([]ListSalesOrdersRow, error) {
	rows, err := q.query(ctx, q.listSalesOrdersStmt, listSalesOrders,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSalesOrdersRow
	for rows.Next() {
		var i ListSalesOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.SoNumber,
			&i.CustomerID,
			&i.CustomerName,
			&i.OrderDate,
			&i.DeliveryDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customers
SET name = $2,
    contact_person = $3,
    email = $4,
    phone = $5,
    address = $6,
    tax_id = $7,
    credit_limit = $8,
    payment_terms = $9,
    is_active = $10,
    updated_at = NOW()
WHERE id = $1 
    AND deleted_at IS NULL
`

type UpdateCustomerParams struct {
	ID            uuid.UUID      `json:"id"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	TaxID         sql.NullString `json:"tax_id"`
	CreditLimit   sql.NullString `json:"credit_limit"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) error {
	_, err := q.exec(ctx, q.updateCustomerStmt, updateCustomer,
		arg.ID,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.TaxID,
		arg.CreditLimit,
		arg.PaymentTerms,
		arg.IsActive,
	)
	return err
}

const updateCustomerInvoicePaidAmount = `-- name: UpdateCustomerInvoicePaidAmount :exec
UPDATE customer_invoices
SET paid_amount = $2,
    status = CASE
        WHEN $2 >= total_amount THEN 'paid'
        WHEN $2 > 0 THEN 'partial'
        ELSE 'unpaid'
    END,
    updated_at = NOW()
WHERE id = $1
`

type UpdateCustomerInvoicePaidAmountParams struct {
	ID         uuid.UUID      `json:"id"`
	PaidAmount sql.NullString `json:"paid_amount"`
}

func (q *Queries) UpdateCustomerInvoicePaidAmount(ctx context.Context, arg UpdateCustomerInvoicePaidAmountParams) error {
	_, err := q.exec(ctx, q.updateCustomerInvoicePaidAmountStmt, updateCustomerInvoicePaidAmount, arg.ID, arg.PaidAmount)
	return err
}

const updateQuotationStatus = `-- name: UpdateQuotationStatus :exec
UPDATE quotations
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateQuotationStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateQuotationStatus(ctx context.Context, arg UpdateQuotationStatusParams) error {
	_, err := q.exec(ctx, q.updateQuotationStatusStmt, updateQuotationStatus, arg.ID, arg.Status)
	return err
}

const updateSOLineDeliveredQty = `-- name: UpdateSOLineDeliveredQty :exec
UPDATE sales_order_lines
SET delivered_qty = delivered_qty + $2
WHERE id = $1
`

type UpdateSOLineDeliveredQtyParams struct {
	ID           uuid.UUID      `json:"id"`
	DeliveredQty sql.NullString `json:"delivered_qty"`
}

func (q *Queries) UpdateSOLineDeliveredQty(ctx context.Context, arg UpdateSOLineDeliveredQtyParams) error {
	_, err := q.exec(ctx, q.updateSOLineDeliveredQtyStmt, updateSOLineDeliveredQty, arg.ID, arg.DeliveredQty)
	return err
}

const updateSalesOrderStatus = `-- name: UpdateSalesOrderStatus :exec
UPDATE sales_orders
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSalesOrderStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateSalesOrderStatus(ctx context.Context, arg UpdateSalesOrderStatusParams) error {
	_, err := q.exec(ctx, q.updateSalesOrderStatusStmt, updateSalesOrderStatus, arg.ID, arg.Status)
	return err
}
