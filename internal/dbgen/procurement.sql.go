// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: procurement.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createGoodsReceipt = `-- name: CreateGoodsReceipt :one
INSERT INTO goods_receipts (
    receipt_number,
    po_id,
    receipt_date,
    notes,
    received_by
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, receipt_number, po_id, receipt_date, created_at
`

type CreateGoodsReceiptParams struct {
	ReceiptNumber string         `json:"receipt_number"`
	PoID          uuid.UUID      `json:"po_id"`
	ReceiptDate   time.Time      `json:"receipt_date"`
	Notes         sql.NullString `json:"notes"`
	ReceivedBy    uuid.NullUUID  `json:"received_by"`
}

type CreateGoodsReceiptRow struct {
	ID            uuid.UUID    `json:"id"`
	ReceiptNumber string       `json:"receipt_number"`
	PoID          uuid.UUID    `json:"po_id"`
	ReceiptDate   time.Time    `json:"receipt_date"`
	CreatedAt     sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateGoodsReceipt(ctx context.Context, arg CreateGoodsReceiptParams) (CreateGoodsReceiptRow, error) {
	row := q.queryRow(ctx, q.createGoodsReceiptStmt, createGoodsReceipt,
		arg.ReceiptNumber,
		arg.PoID,
		arg.ReceiptDate,
		arg.Notes,
		arg.ReceivedBy,
	)
	var i CreateGoodsReceiptRow
	err := row.Scan(
		&i.ID,
		&i.ReceiptNumber,
		&i.PoID,
		&i.ReceiptDate,
		&i.CreatedAt,
	)
	return i, err
}

const createGoodsReceiptLine = `-- name: CreateGoodsReceiptLine :one
INSERT INTO goods_receipt_lines (
    receipt_id,
    po_line_id,
    product_id,
    quantity,
    line_number
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, receipt_id, po_line_id, product_id, quantity, line_number
`

type CreateGoodsReceiptLineParams struct {
	ReceiptID  uuid.UUID `json:"receipt_id"`
	PoLineID   uuid.UUID `json:"po_line_id"`
	ProductID  uuid.UUID `json:"product_id"`
	Quantity   string    `json:"quantity"`
	LineNumber int32     `json:"line_number"`
}

type CreateGoodsReceiptLineRow struct {
	ID         uuid.UUID `json:"id"`
	ReceiptID  uuid.UUID `json:"receipt_id"`
	PoLineID   uuid.UUID `json:"po_line_id"`
	ProductID  uuid.UUID `json:"product_id"`
	Quantity   string    `json:"quantity"`
	LineNumber int32     `json:"line_number"`
}

func (q *Queries) CreateGoodsReceiptLine(ctx context.Context, arg CreateGoodsReceiptLineParams) (CreateGoodsReceiptLineRow, error) {
	row := q.queryRow(ctx, q.createGoodsReceiptLineStmt, createGoodsReceiptLine,
		arg.ReceiptID,
		arg.PoLineID,
		arg.ProductID,
		arg.Quantity,
		arg.LineNumber,
	)
	var i CreateGoodsReceiptLineRow
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.PoLineID,
		&i.ProductID,
		&i.Quantity,
		&i.LineNumber,
	)
	return i, err
}

const createPurchaseOrder = `-- name: CreatePurchaseOrder :one
INSERT INTO purchase_orders (
    po_number,
    supplier_id,
    order_date,
    expected_date,
    status,
    total_amount,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, po_number, supplier_id, order_date, status, created_at
`

type CreatePurchaseOrderParams struct {
	PoNumber     string         `json:"po_number"`
	SupplierID   uuid.UUID      `json:"supplier_id"`
	OrderDate    time.Time      `json:"order_date"`
	ExpectedDate sql.NullTime   `json:"expected_date"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	Notes        sql.NullString `json:"notes"`
	CreatedBy    uuid.NullUUID  `json:"created_by"`
}

type CreatePurchaseOrderRow struct {
	ID         uuid.UUID      `json:"id"`
	PoNumber   string         `json:"po_number"`
	SupplierID uuid.UUID      `json:"supplier_id"`
	OrderDate  time.Time      `json:"order_date"`
	Status     sql.NullString `json:"status"`
	CreatedAt  sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg CreatePurchaseOrderParams) (CreatePurchaseOrderRow, error) {
	row := q.queryRow(ctx, q.createPurchaseOrderStmt, createPurchaseOrder,
		arg.PoNumber,
		arg.SupplierID,
		arg.OrderDate,
		arg.ExpectedDate,
		arg.Status,
		arg.TotalAmount,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreatePurchaseOrderRow
	err := row.Scan(
		&i.ID,
		&i.PoNumber,
		&i.SupplierID,
		&i.OrderDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createPurchaseOrderLine = `-- name: CreatePurchaseOrderLine :one
INSERT INTO purchase_order_lines (
    po_id,
    product_id,
    quantity,
    unit_price,
    line_number,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, po_id, product_id, quantity, unit_price, subtotal, line_number
`

type CreatePurchaseOrderLineParams struct {
	PoID       uuid.UUID      `json:"po_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   string         `json:"quantity"`
	UnitPrice  string         `json:"unit_price"`
	LineNumber int32          `json:"line_number"`
	Notes      sql.NullString `json:"notes"`
}

type CreatePurchaseOrderLineRow struct {
	ID         uuid.UUID      `json:"id"`
	PoID       uuid.UUID      `json:"po_id"`
	ProductID  uuid.UUID      `json:"product_id"`
	Quantity   string         `json:"quantity"`
	UnitPrice  string         `json:"unit_price"`
	Subtotal   sql.NullString `json:"subtotal"`
	LineNumber int32          `json:"line_number"`
}

func (q *Queries) CreatePurchaseOrderLine(ctx context.Context, arg CreatePurchaseOrderLineParams) (CreatePurchaseOrderLineRow, error) {
	row := q.queryRow(ctx, q.createPurchaseOrderLineStmt, createPurchaseOrderLine,
		arg.PoID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.LineNumber,
		arg.Notes,
	)
	var i CreatePurchaseOrderLineRow
	err := row.Scan(
		&i.ID,
		&i.PoID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.LineNumber,
	)
	return i, err
}

const createSupplier = `-- name: CreateSupplier :one
INSERT INTO suppliers (
    code,
    name,
    contact_person,
    email,
    phone,
    address,
    tax_id,
    payment_terms,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, code, name, created_at
`

type CreateSupplierParams struct {
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	TaxID         sql.NullString `json:"tax_id"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
}

type CreateSupplierRow struct {
	ID        uuid.UUID    `json:"id"`
	Code      string       `json:"code"`
	Name      string       `json:"name"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (CreateSupplierRow, error) {
	row := q.queryRow(ctx, q.createSupplierStmt, createSupplier,
		arg.Code,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.TaxID,
		arg.PaymentTerms,
		arg.IsActive,
	)
	var i CreateSupplierRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createSupplierBill = `-- name: CreateSupplierBill :one
INSERT INTO supplier_bills (
    bill_number,
    supplier_id,
    po_id,
    bill_date,
    due_date,
    total_amount,
    status,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, bill_number, supplier_id, bill_date, due_date, total_amount, status, created_at
`

type CreateSupplierBillParams struct {
	BillNumber  string         `json:"bill_number"`
	SupplierID  uuid.UUID      `json:"supplier_id"`
	PoID        uuid.NullUUID  `json:"po_id"`
	BillDate    time.Time      `json:"bill_date"`
	DueDate     time.Time      `json:"due_date"`
	TotalAmount string         `json:"total_amount"`
	Status      sql.NullString `json:"status"`
	Notes       sql.NullString `json:"notes"`
	CreatedBy   uuid.NullUUID  `json:"created_by"`
}

type CreateSupplierBillRow struct {
	ID          uuid.UUID      `json:"id"`
	BillNumber  string         `json:"bill_number"`
	SupplierID  uuid.UUID      `json:"supplier_id"`
	BillDate    time.Time      `json:"bill_date"`
	DueDate     time.Time      `json:"due_date"`
	TotalAmount string         `json:"total_amount"`
	Status      sql.NullString `json:"status"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateSupplierBill(ctx context.Context, arg CreateSupplierBillParams) (CreateSupplierBillRow, error) {
	row := q.queryRow(ctx, q.createSupplierBillStmt, createSupplierBill,
		arg.BillNumber,
		arg.SupplierID,
		arg.PoID,
		arg.BillDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.Status,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreateSupplierBillRow
	err := row.Scan(
		&i.ID,
		&i.BillNumber,
		&i.SupplierID,
		&i.BillDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getGoodsReceiptsByPO = `-- name: GetGoodsReceiptsByPO :many
SELECT 
    gr.id,
    gr.receipt_number,
    gr.po_id,
    gr.receipt_date,
    gr.notes,
    gr.received_by,
    u.full_name as received_by_name,
    gr.created_at
FROM goods_receipts gr
LEFT JOIN users u ON gr.received_by = u.id
WHERE gr.po_id = $1
ORDER BY gr.receipt_date DESC
`

type GetGoodsReceiptsByPORow struct {
	ID             uuid.UUID      `json:"id"`
	ReceiptNumber  string         `json:"receipt_number"`
	PoID           uuid.UUID      `json:"po_id"`
	ReceiptDate    time.Time      `json:"receipt_date"`
	Notes          sql.NullString `json:"notes"`
	ReceivedBy     uuid.NullUUID  `json:"received_by"`
	ReceivedByName sql.NullString `json:"received_by_name"`
	CreatedAt      sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetGoodsReceiptsByPO(ctx context.Context, poID uuid.UUID) ([]GetGoodsReceiptsByPORow, error) {
	rows, err := q.query(ctx, q.getGoodsReceiptsByPOStmt, getGoodsReceiptsByPO, poID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGoodsReceiptsByPORow
	for rows.Next() {
		var i GetGoodsReceiptsByPORow
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptNumber,
			&i.PoID,
			&i.ReceiptDate,
			&i.Notes,
			&i.ReceivedBy,
			&i.ReceivedByName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseOrderByID = `-- name: GetPurchaseOrderByID :one
SELECT 
    po.id,
    po.po_number,
    po.supplier_id,
    s.name as supplier_name,
    po.order_date,
    po.expected_date,
    po.status,
    po.total_amount,
    po.notes,
    po.created_at,
    po.updated_at
FROM purchase_orders po
INNER JOIN suppliers s ON po.supplier_id = s.id
WHERE po.id = $1
LIMIT 1
`

type GetPurchaseOrderByIDRow struct {
	ID           uuid.UUID      `json:"id"`
	PoNumber     string         `json:"po_number"`
	SupplierID   uuid.UUID      `json:"supplier_id"`
	SupplierName string         `json:"supplier_name"`
	OrderDate    time.Time      `json:"order_date"`
	ExpectedDate sql.NullTime   `json:"expected_date"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	Notes        sql.NullString `json:"notes"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetPurchaseOrderByID(ctx context.Context, id uuid.UUID) (GetPurchaseOrderByIDRow, error) {
	row := q.queryRow(ctx, q.getPurchaseOrderByIDStmt, getPurchaseOrderByID, id)
	var i GetPurchaseOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.PoNumber,
		&i.SupplierID,
		&i.SupplierName,
		&i.OrderDate,
		&i.ExpectedDate,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPurchaseOrderLines = `-- name: GetPurchaseOrderLines :many
SELECT 
    pol.id,
    pol.po_id,
    pol.product_id,
    p.code as product_code,
    p.name as product_name,
    pol.quantity,
    pol.unit_price,
    pol.subtotal,
    pol.received_qty,
    pol.line_number,
    pol.notes
FROM purchase_order_lines pol
INNER JOIN products p ON pol.product_id = p.id
WHERE pol.po_id = $1
ORDER BY pol.line_number
`

type GetPurchaseOrderLinesRow struct {
	ID          uuid.UUID      `json:"id"`
	PoID        uuid.UUID      `json:"po_id"`
	ProductID   uuid.UUID      `json:"product_id"`
	ProductCode string         `json:"product_code"`
	ProductName string         `json:"product_name"`
	Quantity    string         `json:"quantity"`
	UnitPrice   string         `json:"unit_price"`
	Subtotal    sql.NullString `json:"subtotal"`
	ReceivedQty sql.NullString `json:"received_qty"`
	LineNumber  int32          `json:"line_number"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) GetPurchaseOrderLines(ctx context.Context, poID uuid.UUID) ([]GetPurchaseOrderLinesRow, error) {
	rows, err := q.query(ctx, q.getPurchaseOrderLinesStmt, getPurchaseOrderLines, poID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPurchaseOrderLinesRow
	for rows.Next() {
		var i GetPurchaseOrderLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.PoID,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.ReceivedQty,
			&i.LineNumber,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierBillByID = `-- name: GetSupplierBillByID :one
SELECT 
    sb.id,
    sb.bill_number,
    sb.supplier_id,
    s.name as supplier_name,
    sb.po_id,
    sb.bill_date,
    sb.due_date,
    sb.total_amount,
    sb.paid_amount,
    sb.status,
    sb.notes,
    sb.created_at
FROM supplier_bills sb
INNER JOIN suppliers s ON sb.supplier_id = s.id
WHERE sb.id = $1
LIMIT 1
`

type GetSupplierBillByIDRow struct {
	ID           uuid.UUID      `json:"id"`
	BillNumber   string         `json:"bill_number"`
	SupplierID   uuid.UUID      `json:"supplier_id"`
	SupplierName string         `json:"supplier_name"`
	PoID         uuid.NullUUID  `json:"po_id"`
	BillDate     time.Time      `json:"bill_date"`
	DueDate      time.Time      `json:"due_date"`
	TotalAmount  string         `json:"total_amount"`
	PaidAmount   sql.NullString `json:"paid_amount"`
	Status       sql.NullString `json:"status"`
	Notes        sql.NullString `json:"notes"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetSupplierBillByID(ctx context.Context, id uuid.UUID) (GetSupplierBillByIDRow, error) {
	row := q.queryRow(ctx, q.getSupplierBillByIDStmt, getSupplierBillByID, id)
	var i GetSupplierBillByIDRow
	err := row.Scan(
		&i.ID,
		&i.BillNumber,
		&i.SupplierID,
		&i.SupplierName,
		&i.PoID,
		&i.BillDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.PaidAmount,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getSupplierByID = `-- name: GetSupplierByID :one
SELECT 
    id,
    code,
    name,
    contact_person,
    email,
    phone,
    address,
    tax_id,
    payment_terms,
    is_active,
    created_at,
    updated_at
FROM suppliers
WHERE id = $1 
    AND deleted_at IS NULL
LIMIT 1
`

type GetSupplierByIDRow struct {
	ID            uuid.UUID      `json:"id"`
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	TaxID         sql.NullString `json:"tax_id"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetSupplierByID(ctx context.Context, id uuid.UUID) (GetSupplierByIDRow, error) {
	row := q.queryRow(ctx, q.getSupplierByIDStmt, getSupplierByID, id)
	var i GetSupplierByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.TaxID,
		&i.PaymentTerms,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveSuppliers = `-- name: ListActiveSuppliers :many
SELECT 
    id,
    code,
    name,
    contact_person,
    email,
    phone,
    payment_terms,
    is_active
FROM suppliers
WHERE deleted_at IS NULL
    AND is_active = true
ORDER BY name
`

type ListActiveSuppliersRow struct {
	ID            uuid.UUID      `json:"id"`
	Code          string         `json:"code"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) ListActiveSuppliers(ctx context.Context) ([]ListActiveSuppliersRow, error) {
	rows, err := q.query(ctx, q.listActiveSuppliersStmt, listActiveSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveSuppliersRow
	for rows.Next() {
		var i ListActiveSuppliersRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.PaymentTerms,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchaseOrders = `-- name: ListPurchaseOrders :many
SELECT 
    po.id,
    po.po_number,
    po.supplier_id,
    s.name as supplier_name,
    po.order_date,
    po.expected_date,
    po.status,
    po.total_amount,
    po.created_at
FROM purchase_orders po
INNER JOIN suppliers s ON po.supplier_id = s.id
WHERE ($1::uuid IS NULL OR po.supplier_id = $1)
    AND ($2::varchar IS NULL OR po.status = $2)
    AND ($3::date IS NULL OR po.order_date >= $3)
    AND ($4::date IS NULL OR po.order_date <= $4)
ORDER BY po.order_date DESC, po.po_number DESC
LIMIT $5 OFFSET $6
`

type ListPurchaseOrdersParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListPurchaseOrdersRow struct {
	ID           uuid.UUID      `json:"id"`
	PoNumber     string         `json:"po_number"`
	SupplierID   uuid.UUID      `json:"supplier_id"`
	SupplierName string         `json:"supplier_name"`
	OrderDate    time.Time      `json:"order_date"`
	ExpectedDate sql.NullTime   `json:"expected_date"`
	Status       sql.NullString `json:"status"`
	TotalAmount  sql.NullString `json:"total_amount"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListPurchaseOrders(ctx context.Context, arg ListPurchaseOrdersParams) ([]ListPurchaseOrdersRow, error) {
	rows, err := q.query(ctx, q.listPurchaseOrdersStmt, listPurchaseOrders,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPurchaseOrdersRow
	for rows.Next() {
		var i ListPurchaseOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.PoNumber,
			&i.SupplierID,
			&i.SupplierName,
			&i.OrderDate,
			&i.ExpectedDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSupplierBills = `-- name: ListSupplierBills :many
SELECT 
    sb.id,
    sb.bill_number,
    sb.supplier_id,
    s.name as supplier_name,
    sb.bill_date,
    sb.due_date,
    sb.total_amount,
    sb.paid_amount,
    (sb.total_amount - sb.paid_amount) as outstanding,
    sb.status,
    sb.created_at
FROM supplier_bills sb
INNER JOIN suppliers s ON sb.supplier_id = s.id
WHERE ($1::uuid IS NULL OR sb.supplier_id = $1)
    AND ($2::varchar IS NULL OR sb.status = $2)
ORDER BY sb.due_date DESC, sb.bill_number DESC
LIMIT $3 OFFSET $4
`

type ListSupplierBillsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListSupplierBillsRow struct {
	ID           uuid.UUID      `json:"id"`
	BillNumber   string         `json:"bill_number"`
	SupplierID   uuid.UUID      `json:"supplier_id"`
	SupplierName string         `json:"supplier_name"`
	BillDate     time.Time      `json:"bill_date"`
	DueDate      time.Time      `json:"due_date"`
	TotalAmount  string         `json:"total_amount"`
	PaidAmount   sql.NullString `json:"paid_amount"`
	Outstanding  int32          `json:"outstanding"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListSupplierBills(ctx context.Context, arg ListSupplierBillsParams) ([]ListSupplierBillsRow, error) {
	rows, err := q.query(ctx, q.listSupplierBillsStmt, listSupplierBills,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSupplierBillsRow
	for rows.Next() {
		var i ListSupplierBillsRow
		if err := rows.Scan(
			&i.ID,
			&i.BillNumber,
			&i.SupplierID,
			&i.SupplierName,
			&i.BillDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.Outstanding,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePOLineReceivedQty = `-- name: UpdatePOLineReceivedQty :exec
UPDATE purchase_order_lines
SET received_qty = received_qty + $2
WHERE id = $1
`

type UpdatePOLineReceivedQtyParams struct {
	ID          uuid.UUID      `json:"id"`
	ReceivedQty sql.NullString `json:"received_qty"`
}

func (q *Queries) UpdatePOLineReceivedQty(ctx context.Context, arg UpdatePOLineReceivedQtyParams) error {
	_, err := q.exec(ctx, q.updatePOLineReceivedQtyStmt, updatePOLineReceivedQty, arg.ID, arg.ReceivedQty)
	return err
}

const updatePurchaseOrderStatus = `-- name: UpdatePurchaseOrderStatus :exec
UPDATE purchase_orders
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdatePurchaseOrderStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdatePurchaseOrderStatus(ctx context.Context, arg UpdatePurchaseOrderStatusParams) error {
	_, err := q.exec(ctx, q.updatePurchaseOrderStatusStmt, updatePurchaseOrderStatus, arg.ID, arg.Status)
	return err
}

const updateSupplier = `-- name: UpdateSupplier :exec
UPDATE suppliers
SET name = $2,
    contact_person = $3,
    email = $4,
    phone = $5,
    address = $6,
    tax_id = $7,
    payment_terms = $8,
    is_active = $9,
    updated_at = NOW()
WHERE id = $1 
    AND deleted_at IS NULL
`

type UpdateSupplierParams struct {
	ID            uuid.UUID      `json:"id"`
	Name          string         `json:"name"`
	ContactPerson sql.NullString `json:"contact_person"`
	Email         sql.NullString `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	TaxID         sql.NullString `json:"tax_id"`
	PaymentTerms  sql.NullInt32  `json:"payment_terms"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) error {
	_, err := q.exec(ctx, q.updateSupplierStmt, updateSupplier,
		arg.ID,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.TaxID,
		arg.PaymentTerms,
		arg.IsActive,
	)
	return err
}

const updateSupplierBillPaidAmount = `-- name: UpdateSupplierBillPaidAmount :exec
UPDATE supplier_bills
SET paid_amount = $2,
    status = CASE
        WHEN $2 >= total_amount THEN 'paid'
        WHEN $2 > 0 THEN 'partial'
        ELSE 'unpaid'
    END,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSupplierBillPaidAmountParams struct {
	ID         uuid.UUID      `json:"id"`
	PaidAmount sql.NullString `json:"paid_amount"`
}

func (q *Queries) UpdateSupplierBillPaidAmount(ctx context.Context, arg UpdateSupplierBillPaidAmountParams) error {
	_, err := q.exec(ctx, q.updateSupplierBillPaidAmountStmt, updateSupplierBillPaidAmount, arg.ID, arg.PaidAmount)
	return err
}
