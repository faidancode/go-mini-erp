// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: finance.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    payment_number,
    payment_type,
    partner_type,
    partner_id,
    invoice_id,
    payment_date,
    amount,
    payment_method,
    reference,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, payment_number, payment_type, partner_id, payment_date, amount, created_at
`

type CreatePaymentParams struct {
	PaymentNumber string         `json:"payment_number"`
	PaymentType   string         `json:"payment_type"`
	PartnerType   string         `json:"partner_type"`
	PartnerID     uuid.UUID      `json:"partner_id"`
	InvoiceID     uuid.NullUUID  `json:"invoice_id"`
	PaymentDate   time.Time      `json:"payment_date"`
	Amount        string         `json:"amount"`
	PaymentMethod sql.NullString `json:"payment_method"`
	Reference     sql.NullString `json:"reference"`
	Notes         sql.NullString `json:"notes"`
	CreatedBy     uuid.NullUUID  `json:"created_by"`
}

type CreatePaymentRow struct {
	ID            uuid.UUID    `json:"id"`
	PaymentNumber string       `json:"payment_number"`
	PaymentType   string       `json:"payment_type"`
	PartnerID     uuid.UUID    `json:"partner_id"`
	PaymentDate   time.Time    `json:"payment_date"`
	Amount        string       `json:"amount"`
	CreatedAt     sql.NullTime `json:"created_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (CreatePaymentRow, error) {
	row := q.queryRow(ctx, q.createPaymentStmt, createPayment,
		arg.PaymentNumber,
		arg.PaymentType,
		arg.PartnerType,
		arg.PartnerID,
		arg.InvoiceID,
		arg.PaymentDate,
		arg.Amount,
		arg.PaymentMethod,
		arg.Reference,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreatePaymentRow
	err := row.Scan(
		&i.ID,
		&i.PaymentNumber,
		&i.PaymentType,
		&i.PartnerID,
		&i.PaymentDate,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const getAccountsPayableSummary = `-- name: GetAccountsPayableSummary :many
SELECT 
    sb.supplier_id,
    s.code as supplier_code,
    s.name as supplier_name,
    COUNT(sb.id) as bill_count,
    SUM(sb.total_amount) as total_billed,
    SUM(sb.paid_amount) as total_paid,
    SUM(sb.total_amount - sb.paid_amount) as outstanding,
    SUM(CASE WHEN sb.status = 'unpaid' THEN 1 ELSE 0 END) as unpaid_count,
    SUM(CASE WHEN sb.status = 'partial' THEN 1 ELSE 0 END) as partial_count,
    MIN(CASE WHEN sb.status != 'paid' THEN sb.due_date END) as earliest_due_date,
    SUM(CASE 
        WHEN sb.status != 'paid' AND sb.due_date < CURRENT_DATE 
        THEN sb.total_amount - sb.paid_amount 
        ELSE 0 
    END) as overdue_amount
FROM supplier_bills sb
INNER JOIN suppliers s ON sb.supplier_id = s.id
WHERE sb.status != 'cancelled'
    AND ($1::uuid IS NULL OR sb.supplier_id = $1)
GROUP BY sb.supplier_id, s.code, s.name
HAVING SUM(sb.total_amount - sb.paid_amount) > 0
ORDER BY outstanding DESC
`

type GetAccountsPayableSummaryRow struct {
	SupplierID      uuid.UUID   `json:"supplier_id"`
	SupplierCode    string      `json:"supplier_code"`
	SupplierName    string      `json:"supplier_name"`
	BillCount       int64       `json:"bill_count"`
	TotalBilled     int64       `json:"total_billed"`
	TotalPaid       int64       `json:"total_paid"`
	Outstanding     int64       `json:"outstanding"`
	UnpaidCount     int64       `json:"unpaid_count"`
	PartialCount    int64       `json:"partial_count"`
	EarliestDueDate interface{} `json:"earliest_due_date"`
	OverdueAmount   int64       `json:"overdue_amount"`
}

func (q *Queries) GetAccountsPayableSummary(ctx context.Context, dollar_1 uuid.UUID) ([]GetAccountsPayableSummaryRow, error) {
	rows, err := q.query(ctx, q.getAccountsPayableSummaryStmt, getAccountsPayableSummary, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsPayableSummaryRow
	for rows.Next() {
		var i GetAccountsPayableSummaryRow
		if err := rows.Scan(
			&i.SupplierID,
			&i.SupplierCode,
			&i.SupplierName,
			&i.BillCount,
			&i.TotalBilled,
			&i.TotalPaid,
			&i.Outstanding,
			&i.UnpaidCount,
			&i.PartialCount,
			&i.EarliestDueDate,
			&i.OverdueAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsReceivableSummary = `-- name: GetAccountsReceivableSummary :many
SELECT 
    ci.customer_id,
    c.code as customer_code,
    c.name as customer_name,
    COUNT(ci.id) as invoice_count,
    SUM(ci.total_amount) as total_invoiced,
    SUM(ci.paid_amount) as total_paid,
    SUM(ci.total_amount - ci.paid_amount) as outstanding,
    SUM(CASE WHEN ci.status = 'unpaid' THEN 1 ELSE 0 END) as unpaid_count,
    SUM(CASE WHEN ci.status = 'partial' THEN 1 ELSE 0 END) as partial_count,
    MIN(CASE WHEN ci.status != 'paid' THEN ci.due_date END) as earliest_due_date,
    SUM(CASE 
        WHEN ci.status != 'paid' AND ci.due_date < CURRENT_DATE 
        THEN ci.total_amount - ci.paid_amount 
        ELSE 0 
    END) as overdue_amount
FROM customer_invoices ci
INNER JOIN customers c ON ci.customer_id = c.id
WHERE ci.status != 'cancelled'
    AND ($1::uuid IS NULL OR ci.customer_id = $1)
GROUP BY ci.customer_id, c.code, c.name
HAVING SUM(ci.total_amount - ci.paid_amount) > 0
ORDER BY outstanding DESC
`

type GetAccountsReceivableSummaryRow struct {
	CustomerID      uuid.UUID   `json:"customer_id"`
	CustomerCode    string      `json:"customer_code"`
	CustomerName    string      `json:"customer_name"`
	InvoiceCount    int64       `json:"invoice_count"`
	TotalInvoiced   int64       `json:"total_invoiced"`
	TotalPaid       int64       `json:"total_paid"`
	Outstanding     int64       `json:"outstanding"`
	UnpaidCount     int64       `json:"unpaid_count"`
	PartialCount    int64       `json:"partial_count"`
	EarliestDueDate interface{} `json:"earliest_due_date"`
	OverdueAmount   int64       `json:"overdue_amount"`
}

func (q *Queries) GetAccountsReceivableSummary(ctx context.Context, dollar_1 uuid.UUID) ([]GetAccountsReceivableSummaryRow, error) {
	rows, err := q.query(ctx, q.getAccountsReceivableSummaryStmt, getAccountsReceivableSummary, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsReceivableSummaryRow
	for rows.Next() {
		var i GetAccountsReceivableSummaryRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.CustomerCode,
			&i.CustomerName,
			&i.InvoiceCount,
			&i.TotalInvoiced,
			&i.TotalPaid,
			&i.Outstanding,
			&i.UnpaidCount,
			&i.PartialCount,
			&i.EarliestDueDate,
			&i.OverdueAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgingReceivables = `-- name: GetAgingReceivables :many
SELECT 
    ci.customer_id,
    c.code as customer_code,
    c.name as customer_name,
    SUM(CASE 
        WHEN ci.due_date >= CURRENT_DATE 
        THEN ci.total_amount - ci.paid_amount 
        ELSE 0 
    END) as current_amount,
    SUM(CASE 
        WHEN ci.due_date < CURRENT_DATE 
        AND ci.due_date >= CURRENT_DATE - INTERVAL '30 days'
        THEN ci.total_amount - ci.paid_amount 
        ELSE 0 
    END) as days_1_30,
    SUM(CASE 
        WHEN ci.due_date < CURRENT_DATE - INTERVAL '30 days'
        AND ci.due_date >= CURRENT_DATE - INTERVAL '60 days'
        THEN ci.total_amount - ci.paid_amount 
        ELSE 0 
    END) as days_31_60,
    SUM(CASE 
        WHEN ci.due_date < CURRENT_DATE - INTERVAL '60 days'
        AND ci.due_date >= CURRENT_DATE - INTERVAL '90 days'
        THEN ci.total_amount - ci.paid_amount 
        ELSE 0 
    END) as days_61_90,
    SUM(CASE 
        WHEN ci.due_date < CURRENT_DATE - INTERVAL '90 days'
        THEN ci.total_amount - ci.paid_amount 
        ELSE 0 
    END) as over_90_days,
    SUM(ci.total_amount - ci.paid_amount) as total_outstanding
FROM customer_invoices ci
INNER JOIN customers c ON ci.customer_id = c.id
WHERE ci.status != 'cancelled'
    AND ci.status != 'paid'
GROUP BY ci.customer_id, c.code, c.name
HAVING SUM(ci.total_amount - ci.paid_amount) > 0
ORDER BY total_outstanding DESC
`

type GetAgingReceivablesRow struct {
	CustomerID       uuid.UUID `json:"customer_id"`
	CustomerCode     string    `json:"customer_code"`
	CustomerName     string    `json:"customer_name"`
	CurrentAmount    int64     `json:"current_amount"`
	Days130          int64     `json:"days_1_30"`
	Days3160         int64     `json:"days_31_60"`
	Days6190         int64     `json:"days_61_90"`
	Over90Days       int64     `json:"over_90_days"`
	TotalOutstanding int64     `json:"total_outstanding"`
}

func (q *Queries) GetAgingReceivables(ctx context.Context) ([]GetAgingReceivablesRow, error) {
	rows, err := q.query(ctx, q.getAgingReceivablesStmt, getAgingReceivables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAgingReceivablesRow
	for rows.Next() {
		var i GetAgingReceivablesRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.CustomerCode,
			&i.CustomerName,
			&i.CurrentAmount,
			&i.Days130,
			&i.Days3160,
			&i.Days6190,
			&i.Over90Days,
			&i.TotalOutstanding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashFlowSummary = `-- name: GetCashFlowSummary :one
SELECT 
    COALESCE(SUM(CASE WHEN payment_type = 'receivable' THEN amount ELSE 0 END), 0)::DECIMAL as cash_in,
    COALESCE(SUM(CASE WHEN payment_type = 'payable' THEN amount ELSE 0 END), 0)::DECIMAL as cash_out,
    (
        COALESCE(SUM(CASE WHEN payment_type = 'receivable' THEN amount ELSE 0 END), 0) - 
        COALESCE(SUM(CASE WHEN payment_type = 'payable' THEN amount ELSE 0 END), 0)
    )::DECIMAL as net_cash_flow
FROM payments
WHERE payment_date >= $1 AND payment_date <= $2
`

type GetCashFlowSummaryParams struct {
	PaymentDate   time.Time `json:"payment_date"`
	PaymentDate_2 time.Time `json:"payment_date_2"`
}

type GetCashFlowSummaryRow struct {
	CashIn      string `json:"cash_in"`
	CashOut     string `json:"cash_out"`
	NetCashFlow string `json:"net_cash_flow"`
}

func (q *Queries) GetCashFlowSummary(ctx context.Context, arg GetCashFlowSummaryParams) (GetCashFlowSummaryRow, error) {
	row := q.queryRow(ctx, q.getCashFlowSummaryStmt, getCashFlowSummary, arg.PaymentDate, arg.PaymentDate_2)
	var i GetCashFlowSummaryRow
	err := row.Scan(&i.CashIn, &i.CashOut, &i.NetCashFlow)
	return i, err
}

const getGrossProfitByProduct = `-- name: GetGrossProfitByProduct :many
SELECT 
    p.id as product_id,
    p.code as product_code,
    p.name as product_name,
    c.name as category_name,
    SUM(sol.quantity) as total_qty_sold,
    SUM(sol.quantity * sol.unit_price) as total_revenue,
    SUM(sol.quantity * p.cost_price) as total_cost,
    SUM(sol.quantity * sol.unit_price) - SUM(sol.quantity * p.cost_price) as gross_profit,
    CASE 
        WHEN SUM(sol.quantity * sol.unit_price) > 0 
        THEN ((SUM(sol.quantity * sol.unit_price) - SUM(sol.quantity * p.cost_price)) / SUM(sol.quantity * sol.unit_price)) * 100
        ELSE 0 
    END as gross_margin_percent
FROM sales_orders so
INNER JOIN sales_order_lines sol ON so.id = sol.so_id
INNER JOIN products p ON sol.product_id = p.id
LEFT JOIN categories c ON p.category_id = c.id
WHERE so.status != 'cancelled'
    AND ($1::date IS NULL OR so.order_date >= $1)
    AND ($2::date IS NULL OR so.order_date <= $2)
    AND ($3::uuid IS NULL OR p.category_id = $3)
GROUP BY p.id, p.code, p.name, c.name
ORDER BY gross_profit DESC
LIMIT $4 OFFSET $5
`

type GetGrossProfitByProductParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 uuid.UUID `json:"column_3"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type GetGrossProfitByProductRow struct {
	ProductID          uuid.UUID      `json:"product_id"`
	ProductCode        string         `json:"product_code"`
	ProductName        string         `json:"product_name"`
	CategoryName       sql.NullString `json:"category_name"`
	TotalQtySold       int64          `json:"total_qty_sold"`
	TotalRevenue       int64          `json:"total_revenue"`
	TotalCost          int64          `json:"total_cost"`
	GrossProfit        int32          `json:"gross_profit"`
	GrossMarginPercent int32          `json:"gross_margin_percent"`
}

func (q *Queries) GetGrossProfitByProduct(ctx context.Context, arg GetGrossProfitByProductParams) ([]GetGrossProfitByProductRow, error) {
	rows, err := q.query(ctx, q.getGrossProfitByProductStmt, getGrossProfitByProduct,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGrossProfitByProductRow
	for rows.Next() {
		var i GetGrossProfitByProductRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.CategoryName,
			&i.TotalQtySold,
			&i.TotalRevenue,
			&i.TotalCost,
			&i.GrossProfit,
			&i.GrossMarginPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrossProfitSummary = `-- name: GetGrossProfitSummary :one
SELECT 
    COUNT(DISTINCT so.id) as total_orders,
    SUM(sol.quantity * sol.unit_price) as total_revenue,
    SUM(sol.quantity * p.cost_price) as total_cost,
    SUM(sol.quantity * sol.unit_price) - SUM(sol.quantity * p.cost_price) as gross_profit,
    CASE 
        WHEN SUM(sol.quantity * sol.unit_price) > 0 
        THEN ((SUM(sol.quantity * sol.unit_price) - SUM(sol.quantity * p.cost_price)) / SUM(sol.quantity * sol.unit_price)) * 100
        ELSE 0 
    END as gross_margin_percent
FROM sales_orders so
INNER JOIN sales_order_lines sol ON so.id = sol.so_id
INNER JOIN products p ON sol.product_id = p.id
WHERE so.status != 'cancelled'
    AND ($1::date IS NULL OR so.order_date >= $1)
    AND ($2::date IS NULL OR so.order_date <= $2)
`

type GetGrossProfitSummaryParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
}

type GetGrossProfitSummaryRow struct {
	TotalOrders        int64 `json:"total_orders"`
	TotalRevenue       int64 `json:"total_revenue"`
	TotalCost          int64 `json:"total_cost"`
	GrossProfit        int32 `json:"gross_profit"`
	GrossMarginPercent int32 `json:"gross_margin_percent"`
}

func (q *Queries) GetGrossProfitSummary(ctx context.Context, arg GetGrossProfitSummaryParams) (GetGrossProfitSummaryRow, error) {
	row := q.queryRow(ctx, q.getGrossProfitSummaryStmt, getGrossProfitSummary, arg.Column1, arg.Column2)
	var i GetGrossProfitSummaryRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalRevenue,
		&i.TotalCost,
		&i.GrossProfit,
		&i.GrossMarginPercent,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT 
    p.id,
    p.payment_number,
    p.payment_type,
    p.partner_type,
    p.partner_id,
    p.invoice_id,
    p.payment_date,
    p.amount,
    p.payment_method,
    p.reference,
    p.notes,
    p.created_at
FROM payments p
WHERE p.id = $1
LIMIT 1
`

type GetPaymentByIDRow struct {
	ID            uuid.UUID      `json:"id"`
	PaymentNumber string         `json:"payment_number"`
	PaymentType   string         `json:"payment_type"`
	PartnerType   string         `json:"partner_type"`
	PartnerID     uuid.UUID      `json:"partner_id"`
	InvoiceID     uuid.NullUUID  `json:"invoice_id"`
	PaymentDate   time.Time      `json:"payment_date"`
	Amount        string         `json:"amount"`
	PaymentMethod sql.NullString `json:"payment_method"`
	Reference     sql.NullString `json:"reference"`
	Notes         sql.NullString `json:"notes"`
	CreatedAt     sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetPaymentByID(ctx context.Context, id uuid.UUID) (GetPaymentByIDRow, error) {
	row := q.queryRow(ctx, q.getPaymentByIDStmt, getPaymentByID, id)
	var i GetPaymentByIDRow
	err := row.Scan(
		&i.ID,
		&i.PaymentNumber,
		&i.PaymentType,
		&i.PartnerType,
		&i.PartnerID,
		&i.InvoiceID,
		&i.PaymentDate,
		&i.Amount,
		&i.PaymentMethod,
		&i.Reference,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
SELECT 
    p.id,
    p.payment_number,
    p.payment_type,
    p.partner_type,
    p.partner_id,
    CASE 
        WHEN p.partner_type = 'customer' THEN c.name
        WHEN p.partner_type = 'supplier' THEN s.name
    END as partner_name,
    p.payment_date,
    p.amount,
    p.payment_method,
    p.reference,
    p.created_at
FROM payments p
LEFT JOIN customers c ON p.partner_type = 'customer' AND p.partner_id = c.id
LEFT JOIN suppliers s ON p.partner_type = 'supplier' AND p.partner_id = s.id
WHERE ($1::varchar IS NULL OR p.payment_type = $1)
    AND ($2::varchar IS NULL OR p.partner_type = $2)
    AND ($3::uuid IS NULL OR p.partner_id = $3)
    AND ($4::date IS NULL OR p.payment_date >= $4)
    AND ($5::date IS NULL OR p.payment_date <= $5)
ORDER BY p.payment_date DESC, p.payment_number DESC
LIMIT $6 OFFSET $7
`

type ListPaymentsParams struct {
	Column1 string    `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 uuid.UUID `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListPaymentsRow struct {
	ID            uuid.UUID      `json:"id"`
	PaymentNumber string         `json:"payment_number"`
	PaymentType   string         `json:"payment_type"`
	PartnerType   string         `json:"partner_type"`
	PartnerID     uuid.UUID      `json:"partner_id"`
	PartnerName   interface{}    `json:"partner_name"`
	PaymentDate   time.Time      `json:"payment_date"`
	Amount        string         `json:"amount"`
	PaymentMethod sql.NullString `json:"payment_method"`
	Reference     sql.NullString `json:"reference"`
	CreatedAt     sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]ListPaymentsRow, error) {
	rows, err := q.query(ctx, q.listPaymentsStmt, listPayments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPaymentsRow
	for rows.Next() {
		var i ListPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PaymentNumber,
			&i.PaymentType,
			&i.PartnerType,
			&i.PartnerID,
			&i.PartnerName,
			&i.PaymentDate,
			&i.Amount,
			&i.PaymentMethod,
			&i.Reference,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
