// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    code,
    name,
    description,
    parent_id,
    is_active
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, code, name, created_at
`

type CreateCategoryParams struct {
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	ParentID    pgtype.UUID `json:"parent_id"`
	IsActive    *bool       `json:"is_active"`
}

type CreateCategoryRow struct {
	ID        uuid.UUID          `json:"id"`
	Code      string             `json:"code"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (CreateCategoryRow, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.ParentID,
		arg.IsActive,
	)
	var i CreateCategoryRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    code,
    name,
    description,
    category_id,
    uom_id,
    product_type,
    cost_price,
    sale_price,
    min_stock,
    max_stock,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, code, name, created_at
`

type CreateProductParams struct {
	Code        string         `json:"code"`
	Name        string         `json:"name"`
	Description *string        `json:"description"`
	CategoryID  pgtype.UUID    `json:"category_id"`
	UomID       uuid.UUID      `json:"uom_id"`
	ProductType *string        `json:"product_type"`
	CostPrice   pgtype.Numeric `json:"cost_price"`
	SalePrice   pgtype.Numeric `json:"sale_price"`
	MinStock    pgtype.Numeric `json:"min_stock"`
	MaxStock    pgtype.Numeric `json:"max_stock"`
	IsActive    *bool          `json:"is_active"`
}

type CreateProductRow struct {
	ID        uuid.UUID          `json:"id"`
	Code      string             `json:"code"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (CreateProductRow, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.UomID,
		arg.ProductType,
		arg.CostPrice,
		arg.SalePrice,
		arg.MinStock,
		arg.MaxStock,
		arg.IsActive,
	)
	var i CreateProductRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createStockAdjustment = `-- name: CreateStockAdjustment :one
INSERT INTO stock_adjustments (
    adjustment_number,
    location_id,
    adjustment_date,
    reason,
    status,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, adjustment_number, location_id, adjustment_date, status, created_at
`

type CreateStockAdjustmentParams struct {
	AdjustmentNumber string      `json:"adjustment_number"`
	LocationID       uuid.UUID   `json:"location_id"`
	AdjustmentDate   pgtype.Date `json:"adjustment_date"`
	Reason           *string     `json:"reason"`
	Status           *string     `json:"status"`
	CreatedBy        pgtype.UUID `json:"created_by"`
}

type CreateStockAdjustmentRow struct {
	ID               uuid.UUID          `json:"id"`
	AdjustmentNumber string             `json:"adjustment_number"`
	LocationID       uuid.UUID          `json:"location_id"`
	AdjustmentDate   pgtype.Date        `json:"adjustment_date"`
	Status           *string            `json:"status"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateStockAdjustment(ctx context.Context, arg CreateStockAdjustmentParams) (CreateStockAdjustmentRow, error) {
	row := q.db.QueryRow(ctx, createStockAdjustment,
		arg.AdjustmentNumber,
		arg.LocationID,
		arg.AdjustmentDate,
		arg.Reason,
		arg.Status,
		arg.CreatedBy,
	)
	var i CreateStockAdjustmentRow
	err := row.Scan(
		&i.ID,
		&i.AdjustmentNumber,
		&i.LocationID,
		&i.AdjustmentDate,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createStockAdjustmentLine = `-- name: CreateStockAdjustmentLine :one
INSERT INTO stock_adjustment_lines (
    adjustment_id,
    product_id,
    quantity_before,
    quantity_after,
    line_number,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, adjustment_id, product_id, quantity_before, quantity_after, difference, line_number
`

type CreateStockAdjustmentLineParams struct {
	AdjustmentID   uuid.UUID      `json:"adjustment_id"`
	ProductID      uuid.UUID      `json:"product_id"`
	QuantityBefore pgtype.Numeric `json:"quantity_before"`
	QuantityAfter  pgtype.Numeric `json:"quantity_after"`
	LineNumber     int32          `json:"line_number"`
	Notes          *string        `json:"notes"`
}

type CreateStockAdjustmentLineRow struct {
	ID             uuid.UUID      `json:"id"`
	AdjustmentID   uuid.UUID      `json:"adjustment_id"`
	ProductID      uuid.UUID      `json:"product_id"`
	QuantityBefore pgtype.Numeric `json:"quantity_before"`
	QuantityAfter  pgtype.Numeric `json:"quantity_after"`
	Difference     pgtype.Numeric `json:"difference"`
	LineNumber     int32          `json:"line_number"`
}

func (q *Queries) CreateStockAdjustmentLine(ctx context.Context, arg CreateStockAdjustmentLineParams) (CreateStockAdjustmentLineRow, error) {
	row := q.db.QueryRow(ctx, createStockAdjustmentLine,
		arg.AdjustmentID,
		arg.ProductID,
		arg.QuantityBefore,
		arg.QuantityAfter,
		arg.LineNumber,
		arg.Notes,
	)
	var i CreateStockAdjustmentLineRow
	err := row.Scan(
		&i.ID,
		&i.AdjustmentID,
		&i.ProductID,
		&i.QuantityBefore,
		&i.QuantityAfter,
		&i.Difference,
		&i.LineNumber,
	)
	return i, err
}

const createStockLocation = `-- name: CreateStockLocation :one
INSERT INTO stock_locations (
    code,
    name,
    location_type,
    is_active
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, code, name, location_type
`

type CreateStockLocationParams struct {
	Code         string  `json:"code"`
	Name         string  `json:"name"`
	LocationType *string `json:"location_type"`
	IsActive     *bool   `json:"is_active"`
}

type CreateStockLocationRow struct {
	ID           uuid.UUID `json:"id"`
	Code         string    `json:"code"`
	Name         string    `json:"name"`
	LocationType *string   `json:"location_type"`
}

func (q *Queries) CreateStockLocation(ctx context.Context, arg CreateStockLocationParams) (CreateStockLocationRow, error) {
	row := q.db.QueryRow(ctx, createStockLocation,
		arg.Code,
		arg.Name,
		arg.LocationType,
		arg.IsActive,
	)
	var i CreateStockLocationRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.LocationType,
	)
	return i, err
}

const createStockMovement = `-- name: CreateStockMovement :one
INSERT INTO stock_movements (
    movement_number,
    product_id,
    location_id,
    movement_type,
    quantity,
    reference_type,
    reference_id,
    movement_date,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, movement_number, product_id, location_id, movement_type, quantity, movement_date
`

type CreateStockMovementParams struct {
	MovementNumber string             `json:"movement_number"`
	ProductID      uuid.UUID          `json:"product_id"`
	LocationID     uuid.UUID          `json:"location_id"`
	MovementType   string             `json:"movement_type"`
	Quantity       pgtype.Numeric     `json:"quantity"`
	ReferenceType  *string            `json:"reference_type"`
	ReferenceID    pgtype.UUID        `json:"reference_id"`
	MovementDate   pgtype.Timestamptz `json:"movement_date"`
	Notes          *string            `json:"notes"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
}

type CreateStockMovementRow struct {
	ID             uuid.UUID          `json:"id"`
	MovementNumber string             `json:"movement_number"`
	ProductID      uuid.UUID          `json:"product_id"`
	LocationID     uuid.UUID          `json:"location_id"`
	MovementType   string             `json:"movement_type"`
	Quantity       pgtype.Numeric     `json:"quantity"`
	MovementDate   pgtype.Timestamptz `json:"movement_date"`
}

func (q *Queries) CreateStockMovement(ctx context.Context, arg CreateStockMovementParams) (CreateStockMovementRow, error) {
	row := q.db.QueryRow(ctx, createStockMovement,
		arg.MovementNumber,
		arg.ProductID,
		arg.LocationID,
		arg.MovementType,
		arg.Quantity,
		arg.ReferenceType,
		arg.ReferenceID,
		arg.MovementDate,
		arg.Notes,
		arg.CreatedBy,
	)
	var i CreateStockMovementRow
	err := row.Scan(
		&i.ID,
		&i.MovementNumber,
		&i.ProductID,
		&i.LocationID,
		&i.MovementType,
		&i.Quantity,
		&i.MovementDate,
	)
	return i, err
}

const createUnitOfMeasure = `-- name: CreateUnitOfMeasure :one
INSERT INTO units_of_measure (
    code,
    name,
    unit_type,
    is_base_unit,
    conversion_factor,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, code, name, unit_type
`

type CreateUnitOfMeasureParams struct {
	Code             string         `json:"code"`
	Name             string         `json:"name"`
	UnitType         string         `json:"unit_type"`
	IsBaseUnit       *bool          `json:"is_base_unit"`
	ConversionFactor pgtype.Numeric `json:"conversion_factor"`
	IsActive         *bool          `json:"is_active"`
}

type CreateUnitOfMeasureRow struct {
	ID       uuid.UUID `json:"id"`
	Code     string    `json:"code"`
	Name     string    `json:"name"`
	UnitType string    `json:"unit_type"`
}

func (q *Queries) CreateUnitOfMeasure(ctx context.Context, arg CreateUnitOfMeasureParams) (CreateUnitOfMeasureRow, error) {
	row := q.db.QueryRow(ctx, createUnitOfMeasure,
		arg.Code,
		arg.Name,
		arg.UnitType,
		arg.IsBaseUnit,
		arg.ConversionFactor,
		arg.IsActive,
	)
	var i CreateUnitOfMeasureRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.UnitType,
	)
	return i, err
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT 
    id,
    code,
    name,
    description,
    parent_id,
    is_active,
    created_at,
    updated_at
FROM categories
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByCode = `-- name: GetProductByCode :one
SELECT 
    p.id,
    p.code,
    p.name,
    p.description,
    p.category_id,
    p.uom_id,
    p.product_type,
    p.cost_price,
    p.sale_price,
    p.is_active
FROM products p
WHERE p.code = $1 
    AND p.deleted_at IS NULL
LIMIT 1
`

type GetProductByCodeRow struct {
	ID          uuid.UUID      `json:"id"`
	Code        string         `json:"code"`
	Name        string         `json:"name"`
	Description *string        `json:"description"`
	CategoryID  pgtype.UUID    `json:"category_id"`
	UomID       uuid.UUID      `json:"uom_id"`
	ProductType *string        `json:"product_type"`
	CostPrice   pgtype.Numeric `json:"cost_price"`
	SalePrice   pgtype.Numeric `json:"sale_price"`
	IsActive    *bool          `json:"is_active"`
}

func (q *Queries) GetProductByCode(ctx context.Context, code string) (GetProductByCodeRow, error) {
	row := q.db.QueryRow(ctx, getProductByCode, code)
	var i GetProductByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.UomID,
		&i.ProductType,
		&i.CostPrice,
		&i.SalePrice,
		&i.IsActive,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT 
    p.id,
    p.code,
    p.name,
    p.description,
    p.category_id,
    c.name as category_name,
    p.uom_id,
    u.code as uom_code,
    u.name as uom_name,
    p.product_type,
    p.cost_price,
    p.sale_price,
    p.min_stock,
    p.max_stock,
    p.is_active,
    p.created_at,
    p.updated_at
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
INNER JOIN units_of_measure u ON p.uom_id = u.id
WHERE p.id = $1 
    AND p.deleted_at IS NULL
LIMIT 1
`

type GetProductByIDRow struct {
	ID           uuid.UUID          `json:"id"`
	Code         string             `json:"code"`
	Name         string             `json:"name"`
	Description  *string            `json:"description"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	CategoryName *string            `json:"category_name"`
	UomID        uuid.UUID          `json:"uom_id"`
	UomCode      string             `json:"uom_code"`
	UomName      string             `json:"uom_name"`
	ProductType  *string            `json:"product_type"`
	CostPrice    pgtype.Numeric     `json:"cost_price"`
	SalePrice    pgtype.Numeric     `json:"sale_price"`
	MinStock     pgtype.Numeric     `json:"min_stock"`
	MaxStock     pgtype.Numeric     `json:"max_stock"`
	IsActive     *bool              `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.CategoryName,
		&i.UomID,
		&i.UomCode,
		&i.UomName,
		&i.ProductType,
		&i.CostPrice,
		&i.SalePrice,
		&i.MinStock,
		&i.MaxStock,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStockAdjustmentByID = `-- name: GetStockAdjustmentByID :one
SELECT 
    sa.id,
    sa.adjustment_number,
    sa.location_id,
    sl.name as location_name,
    sa.adjustment_date,
    sa.reason,
    sa.status,
    sa.created_by,
    u.full_name as created_by_name,
    sa.created_at,
    sa.updated_at
FROM stock_adjustments sa
INNER JOIN stock_locations sl ON sa.location_id = sl.id
LEFT JOIN users u ON sa.created_by = u.id
WHERE sa.id = $1
LIMIT 1
`

type GetStockAdjustmentByIDRow struct {
	ID               uuid.UUID          `json:"id"`
	AdjustmentNumber string             `json:"adjustment_number"`
	LocationID       uuid.UUID          `json:"location_id"`
	LocationName     string             `json:"location_name"`
	AdjustmentDate   pgtype.Date        `json:"adjustment_date"`
	Reason           *string            `json:"reason"`
	Status           *string            `json:"status"`
	CreatedBy        pgtype.UUID        `json:"created_by"`
	CreatedByName    *string            `json:"created_by_name"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetStockAdjustmentByID(ctx context.Context, id uuid.UUID) (GetStockAdjustmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getStockAdjustmentByID, id)
	var i GetStockAdjustmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.AdjustmentNumber,
		&i.LocationID,
		&i.LocationName,
		&i.AdjustmentDate,
		&i.Reason,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedByName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStockAdjustmentLines = `-- name: GetStockAdjustmentLines :many
SELECT 
    sal.id,
    sal.adjustment_id,
    sal.product_id,
    p.code as product_code,
    p.name as product_name,
    sal.quantity_before,
    sal.quantity_after,
    sal.difference,
    sal.line_number,
    sal.notes
FROM stock_adjustment_lines sal
INNER JOIN products p ON sal.product_id = p.id
WHERE sal.adjustment_id = $1
ORDER BY sal.line_number
`

type GetStockAdjustmentLinesRow struct {
	ID             uuid.UUID      `json:"id"`
	AdjustmentID   uuid.UUID      `json:"adjustment_id"`
	ProductID      uuid.UUID      `json:"product_id"`
	ProductCode    string         `json:"product_code"`
	ProductName    string         `json:"product_name"`
	QuantityBefore pgtype.Numeric `json:"quantity_before"`
	QuantityAfter  pgtype.Numeric `json:"quantity_after"`
	Difference     pgtype.Numeric `json:"difference"`
	LineNumber     int32          `json:"line_number"`
	Notes          *string        `json:"notes"`
}

func (q *Queries) GetStockAdjustmentLines(ctx context.Context, adjustmentID uuid.UUID) ([]GetStockAdjustmentLinesRow, error) {
	rows, err := q.db.Query(ctx, getStockAdjustmentLines, adjustmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStockAdjustmentLinesRow
	for rows.Next() {
		var i GetStockAdjustmentLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.AdjustmentID,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.QuantityBefore,
			&i.QuantityAfter,
			&i.Difference,
			&i.LineNumber,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockBalance = `-- name: GetStockBalance :one
SELECT 
    sb.id,
    sb.product_id,
    p.code as product_code,
    p.name as product_name,
    sb.location_id,
    sl.name as location_name,
    sb.quantity,
    sb.reserved_qty,
    sb.available_qty,
    sb.last_updated
FROM stock_balances sb
INNER JOIN products p ON sb.product_id = p.id
INNER JOIN stock_locations sl ON sb.location_id = sl.id
WHERE sb.product_id = $1 
    AND sb.location_id = $2
LIMIT 1
`

type GetStockBalanceParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	LocationID uuid.UUID `json:"location_id"`
}

type GetStockBalanceRow struct {
	ID           uuid.UUID          `json:"id"`
	ProductID    uuid.UUID          `json:"product_id"`
	ProductCode  string             `json:"product_code"`
	ProductName  string             `json:"product_name"`
	LocationID   uuid.UUID          `json:"location_id"`
	LocationName string             `json:"location_name"`
	Quantity     pgtype.Numeric     `json:"quantity"`
	ReservedQty  pgtype.Numeric     `json:"reserved_qty"`
	AvailableQty pgtype.Numeric     `json:"available_qty"`
	LastUpdated  pgtype.Timestamptz `json:"last_updated"`
}

func (q *Queries) GetStockBalance(ctx context.Context, arg GetStockBalanceParams) (GetStockBalanceRow, error) {
	row := q.db.QueryRow(ctx, getStockBalance, arg.ProductID, arg.LocationID)
	var i GetStockBalanceRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductCode,
		&i.ProductName,
		&i.LocationID,
		&i.LocationName,
		&i.Quantity,
		&i.ReservedQty,
		&i.AvailableQty,
		&i.LastUpdated,
	)
	return i, err
}

const listActiveCategories = `-- name: ListActiveCategories :many
SELECT 
    id,
    code,
    name,
    description,
    parent_id,
    is_active
FROM categories
WHERE is_active = true
ORDER BY name
`

type ListActiveCategoriesRow struct {
	ID          uuid.UUID   `json:"id"`
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	ParentID    pgtype.UUID `json:"parent_id"`
	IsActive    *bool       `json:"is_active"`
}

func (q *Queries) ListActiveCategories(ctx context.Context) ([]ListActiveCategoriesRow, error) {
	rows, err := q.db.Query(ctx, listActiveCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveCategoriesRow
	for rows.Next() {
		var i ListActiveCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.ParentID,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveProducts = `-- name: ListActiveProducts :many
SELECT 
    p.id,
    p.code,
    p.name,
    p.category_id,
    c.name as category_name,
    p.product_type,
    p.cost_price,
    p.sale_price,
    p.is_active
FROM products p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.deleted_at IS NULL
    AND p.is_active = true
    AND ($1::uuid IS NULL OR p.category_id = $1)
ORDER BY p.name
`

type ListActiveProductsRow struct {
	ID           uuid.UUID      `json:"id"`
	Code         string         `json:"code"`
	Name         string         `json:"name"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	CategoryName *string        `json:"category_name"`
	ProductType  *string        `json:"product_type"`
	CostPrice    pgtype.Numeric `json:"cost_price"`
	SalePrice    pgtype.Numeric `json:"sale_price"`
	IsActive     *bool          `json:"is_active"`
}

func (q *Queries) ListActiveProducts(ctx context.Context, dollar_1 uuid.UUID) ([]ListActiveProductsRow, error) {
	rows, err := q.db.Query(ctx, listActiveProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveProductsRow
	for rows.Next() {
		var i ListActiveProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CategoryID,
			&i.CategoryName,
			&i.ProductType,
			&i.CostPrice,
			&i.SalePrice,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveStockLocations = `-- name: ListActiveStockLocations :many
SELECT 
    id,
    code,
    name,
    location_type,
    is_active
FROM stock_locations
WHERE is_active = true
ORDER BY name
`

type ListActiveStockLocationsRow struct {
	ID           uuid.UUID `json:"id"`
	Code         string    `json:"code"`
	Name         string    `json:"name"`
	LocationType *string   `json:"location_type"`
	IsActive     *bool     `json:"is_active"`
}

func (q *Queries) ListActiveStockLocations(ctx context.Context) ([]ListActiveStockLocationsRow, error) {
	rows, err := q.db.Query(ctx, listActiveStockLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveStockLocationsRow
	for rows.Next() {
		var i ListActiveStockLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.LocationType,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveUoM = `-- name: ListActiveUoM :many
SELECT 
    id,
    code,
    name,
    unit_type,
    is_base_unit,
    conversion_factor
FROM units_of_measure
WHERE is_active = true
ORDER BY unit_type, name
`

type ListActiveUoMRow struct {
	ID               uuid.UUID      `json:"id"`
	Code             string         `json:"code"`
	Name             string         `json:"name"`
	UnitType         string         `json:"unit_type"`
	IsBaseUnit       *bool          `json:"is_base_unit"`
	ConversionFactor pgtype.Numeric `json:"conversion_factor"`
}

func (q *Queries) ListActiveUoM(ctx context.Context) ([]ListActiveUoMRow, error) {
	rows, err := q.db.Query(ctx, listActiveUoM)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveUoMRow
	for rows.Next() {
		var i ListActiveUoMRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.UnitType,
			&i.IsBaseUnit,
			&i.ConversionFactor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockAdjustments = `-- name: ListStockAdjustments :many
SELECT 
    sa.id,
    sa.adjustment_number,
    sa.location_id,
    sl.name as location_name,
    sa.adjustment_date,
    sa.reason,
    sa.status,
    sa.created_at
FROM stock_adjustments sa
INNER JOIN stock_locations sl ON sa.location_id = sl.id
WHERE ($1::uuid IS NULL OR sa.location_id = $1)
    AND ($2::varchar IS NULL OR sa.status = $2)
ORDER BY sa.adjustment_date DESC, sa.adjustment_number DESC
LIMIT $3 OFFSET $4
`

type ListStockAdjustmentsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListStockAdjustmentsRow struct {
	ID               uuid.UUID          `json:"id"`
	AdjustmentNumber string             `json:"adjustment_number"`
	LocationID       uuid.UUID          `json:"location_id"`
	LocationName     string             `json:"location_name"`
	AdjustmentDate   pgtype.Date        `json:"adjustment_date"`
	Reason           *string            `json:"reason"`
	Status           *string            `json:"status"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListStockAdjustments(ctx context.Context, arg ListStockAdjustmentsParams) ([]ListStockAdjustmentsRow, error) {
	rows, err := q.db.Query(ctx, listStockAdjustments,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockAdjustmentsRow
	for rows.Next() {
		var i ListStockAdjustmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.AdjustmentNumber,
			&i.LocationID,
			&i.LocationName,
			&i.AdjustmentDate,
			&i.Reason,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockBalances = `-- name: ListStockBalances :many
SELECT 
    sb.id,
    sb.product_id,
    p.code as product_code,
    p.name as product_name,
    sb.location_id,
    sl.name as location_name,
    sb.quantity,
    sb.reserved_qty,
    sb.available_qty,
    p.min_stock,
    p.max_stock,
    sb.last_updated
FROM stock_balances sb
INNER JOIN products p ON sb.product_id = p.id
INNER JOIN stock_locations sl ON sb.location_id = sl.id
WHERE ($1::uuid IS NULL OR sb.product_id = $1)
    AND ($2::uuid IS NULL OR sb.location_id = $2)
    AND ($3::boolean IS NULL OR (sb.quantity > 0) = $3)
ORDER BY p.name, sl.name
`

type ListStockBalancesParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
	Column3 bool      `json:"column_3"`
}

type ListStockBalancesRow struct {
	ID           uuid.UUID          `json:"id"`
	ProductID    uuid.UUID          `json:"product_id"`
	ProductCode  string             `json:"product_code"`
	ProductName  string             `json:"product_name"`
	LocationID   uuid.UUID          `json:"location_id"`
	LocationName string             `json:"location_name"`
	Quantity     pgtype.Numeric     `json:"quantity"`
	ReservedQty  pgtype.Numeric     `json:"reserved_qty"`
	AvailableQty pgtype.Numeric     `json:"available_qty"`
	MinStock     pgtype.Numeric     `json:"min_stock"`
	MaxStock     pgtype.Numeric     `json:"max_stock"`
	LastUpdated  pgtype.Timestamptz `json:"last_updated"`
}

func (q *Queries) ListStockBalances(ctx context.Context, arg ListStockBalancesParams) ([]ListStockBalancesRow, error) {
	rows, err := q.db.Query(ctx, listStockBalances, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockBalancesRow
	for rows.Next() {
		var i ListStockBalancesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.LocationID,
			&i.LocationName,
			&i.Quantity,
			&i.ReservedQty,
			&i.AvailableQty,
			&i.MinStock,
			&i.MaxStock,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStockMovements = `-- name: ListStockMovements :many
SELECT 
    sm.id,
    sm.movement_number,
    sm.product_id,
    p.code as product_code,
    p.name as product_name,
    sm.location_id,
    sl.name as location_name,
    sm.movement_type,
    sm.quantity,
    sm.reference_type,
    sm.reference_id,
    sm.movement_date,
    sm.notes,
    sm.created_at
FROM stock_movements sm
INNER JOIN products p ON sm.product_id = p.id
INNER JOIN stock_locations sl ON sm.location_id = sl.id
WHERE ($1::uuid IS NULL OR sm.product_id = $1)
    AND ($2::uuid IS NULL OR sm.location_id = $2)
    AND ($3::varchar IS NULL OR sm.movement_type = $3)
    AND ($4::timestamptz IS NULL OR sm.movement_date >= $4)
    AND ($5::timestamptz IS NULL OR sm.movement_date <= $5)
ORDER BY sm.movement_date DESC, sm.created_at DESC
LIMIT $6 OFFSET $7
`

type ListStockMovementsParams struct {
	Column1 uuid.UUID          `json:"column_1"`
	Column2 uuid.UUID          `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

type ListStockMovementsRow struct {
	ID             uuid.UUID          `json:"id"`
	MovementNumber string             `json:"movement_number"`
	ProductID      uuid.UUID          `json:"product_id"`
	ProductCode    string             `json:"product_code"`
	ProductName    string             `json:"product_name"`
	LocationID     uuid.UUID          `json:"location_id"`
	LocationName   string             `json:"location_name"`
	MovementType   string             `json:"movement_type"`
	Quantity       pgtype.Numeric     `json:"quantity"`
	ReferenceType  *string            `json:"reference_type"`
	ReferenceID    pgtype.UUID        `json:"reference_id"`
	MovementDate   pgtype.Timestamptz `json:"movement_date"`
	Notes          *string            `json:"notes"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListStockMovements(ctx context.Context, arg ListStockMovementsParams) ([]ListStockMovementsRow, error) {
	rows, err := q.db.Query(ctx, listStockMovements,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockMovementsRow
	for rows.Next() {
		var i ListStockMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.MovementNumber,
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.LocationID,
			&i.LocationName,
			&i.MovementType,
			&i.Quantity,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.MovementDate,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET name = $2,
    description = $3,
    category_id = $4,
    cost_price = $5,
    sale_price = $6,
    min_stock = $7,
    max_stock = $8,
    is_active = $9,
    updated_at = NOW()
WHERE id = $1 
    AND deleted_at IS NULL
`

type UpdateProductParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description *string        `json:"description"`
	CategoryID  pgtype.UUID    `json:"category_id"`
	CostPrice   pgtype.Numeric `json:"cost_price"`
	SalePrice   pgtype.Numeric `json:"sale_price"`
	MinStock    pgtype.Numeric `json:"min_stock"`
	MaxStock    pgtype.Numeric `json:"max_stock"`
	IsActive    *bool          `json:"is_active"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.CostPrice,
		arg.SalePrice,
		arg.MinStock,
		arg.MaxStock,
		arg.IsActive,
	)
	return err
}

const updateStockAdjustmentStatus = `-- name: UpdateStockAdjustmentStatus :exec
UPDATE stock_adjustments
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateStockAdjustmentStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateStockAdjustmentStatus(ctx context.Context, arg UpdateStockAdjustmentStatusParams) error {
	_, err := q.db.Exec(ctx, updateStockAdjustmentStatus, arg.ID, arg.Status)
	return err
}

const updateStockQuantity = `-- name: UpdateStockQuantity :exec
UPDATE stock_balances
SET quantity = quantity + $3,
    last_updated = NOW()
WHERE product_id = $1 
    AND location_id = $2
`

type UpdateStockQuantityParams struct {
	ProductID  uuid.UUID      `json:"product_id"`
	LocationID uuid.UUID      `json:"location_id"`
	Quantity   pgtype.Numeric `json:"quantity"`
}

func (q *Queries) UpdateStockQuantity(ctx context.Context, arg UpdateStockQuantityParams) error {
	_, err := q.db.Exec(ctx, updateStockQuantity, arg.ProductID, arg.LocationID, arg.Quantity)
	return err
}

const upsertStockBalance = `-- name: UpsertStockBalance :one
INSERT INTO stock_balances (
    product_id,
    location_id,
    quantity,
    reserved_qty,
    last_updated
) VALUES (
    $1, $2, $3, $4, NOW()
)
ON CONFLICT (product_id, location_id)
DO UPDATE SET
    quantity = stock_balances.quantity + EXCLUDED.quantity,
    last_updated = NOW()
RETURNING id, product_id, location_id, quantity, reserved_qty, available_qty
`

type UpsertStockBalanceParams struct {
	ProductID   uuid.UUID      `json:"product_id"`
	LocationID  uuid.UUID      `json:"location_id"`
	Quantity    pgtype.Numeric `json:"quantity"`
	ReservedQty pgtype.Numeric `json:"reserved_qty"`
}

type UpsertStockBalanceRow struct {
	ID           uuid.UUID      `json:"id"`
	ProductID    uuid.UUID      `json:"product_id"`
	LocationID   uuid.UUID      `json:"location_id"`
	Quantity     pgtype.Numeric `json:"quantity"`
	ReservedQty  pgtype.Numeric `json:"reserved_qty"`
	AvailableQty pgtype.Numeric `json:"available_qty"`
}

func (q *Queries) UpsertStockBalance(ctx context.Context, arg UpsertStockBalanceParams) (UpsertStockBalanceRow, error) {
	row := q.db.QueryRow(ctx, upsertStockBalance,
		arg.ProductID,
		arg.LocationID,
		arg.Quantity,
		arg.ReservedQty,
	)
	var i UpsertStockBalanceRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.LocationID,
		&i.Quantity,
		&i.ReservedQty,
		&i.AvailableQty,
	)
	return i, err
}
